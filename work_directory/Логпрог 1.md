Вот ответы на контрольные вопросы, объяснённые простым и понятным языком, как будто объясняю другу, который только начинает разбираться в программировании:

1. **Парадигмы программирования**  
   Парадигма — это как стиль или подход к написанию программ. Представь, что ты готовишь еду: можно следовать рецепту шаг за шагом или просто сказать, что хочешь на столе.  
   - **Императивная**: ты даёшь компьютеру точные инструкции, как делать (например, «возьми муку, добавь воду»). Это процедурное (пишешь функции), объектно-ориентированное (работаешь с объектами, как в жизни) или структурное программирование (код организован в блоки).  
   - **Декларативная**: ты говоришь, что хочешь получить (например, «мне нужна пицца»), а не как её делать. Это функциональное (работа с функциями, как в математике) и логическое программирование (опирается на логику и правила).  

2. **Преобразование предложений естественного языка в логику предикатов**  
   Это когда обычные фразы переводят в формулы, понятные компьютеру. Например:  
   - «Роза красная» → `красная(роза)` (роза имеет свойство «красная»).  
   - «Монополия — игра» → `игра(монополия)` (монополия относится к играм).  
   - «Ане нравится монополия, если это игра» → `нравится(аня, монополия) :- игра(монополия)` (Аня любит монополию, только если монополия — игра).  
   Это как перевести обычную речь в математическую логику.  

3. **Предпосылки появления логического программирования**  
   Логическое программирование появилось, потому что обычные языки не справлялись с некоторыми задачами:  
   - Данные не числа, а слова или символы (например, имена или отношения).  
   - Нет чёткого алгоритма, как решить задачу.  
   - Данные могут противоречить друг другу.  
   Обычные программы плохо справлялись: их сложно менять, они не могут сами доопределять правила или искать разные решения. Логическое программирование решило эти проблемы, позволяя описывать правила и отношения, а не шаги.  

4. **Историческая справка о языке Пролог**  
   Пролог (сокращение от «программирование в логике») придумали в 1971 году во Франции, в Марсельском университете. Первый работающий Пролог появился в 1973 году благодаря Ф. Расселу. В 80-х он стал популярным, потому что:  
   - Компания DEC захотела его использовать.  
   - Учёные доказали, что Пролог математически надёжен.  
   - Японцы выбрали его для проекта «компьютеры будущего» (FGCS).  
   Пролог до сих пор используют для задач с логикой, базами знаний и искусственным интеллектом.  

5. **Достоинства и недостатки языка Пролог**  
   **Плюсы**:  
   - Можно просто описать проблему и правила, а Пролог сам найдёт решение.  
   - Он ищет все возможные варианты ответа (это называется «возврат»).  
   - Код писать легко, синтаксис простой.  
   **Минусы**:  
   - Пролог не подходит для больших и сложных задач без других языков.  
   - Его мало развивают, потому что в него не вкладывают деньги.  
   - Плохо справляется с вычислениями, вроде обработки видео или музыки.  

6. **Элементы логических исчислений (формула, интерпретации)**  
   Логическое исчисление — это как математика для логики.  
   - **Формула**: это логическое выражение, например, «A и B» (`A & B`) или «не A» (`¬A`). Формулы строятся по строгим правилам, чтобы компьютер их понял.  
   - **Интерпретация**: это когда мы задаём значения (правда = 1, ложь = 0) переменным в формуле. Например, для `A ∨ ¬B` мы проверяем, будет ли формула правдой или ложью при разных значениях A и B.  

7. **Аксиомы исчисления высказываний**  
   Аксиомы — это базовые правила логики, которые всегда верны. Их используют, чтобы строить другие логические выводы. Пример простых аксиом:  
   - Если A правда, то B не делает A ложной (`A → (B → A)`).  
   - Если A ведёт к B, а B к C, то A ведёт к C.  
   Есть ещё система Новикова с 11 аксиомами, которые добавляют правила для «и», «или» и «не». Это как фундамент для логических доказательств.  

8. **Теоремы алгебры логики**  
   Это правила, которые помогают упрощать логические выражения. Например:  
   - **Де Моргана**: «не (A или B)» то же, что «не A и не B» (`¬(A ∨ B) ≡ ¬A & ¬B`).  
   - **Контрапозиция**: «если A, то B» то же, что «если не B, то не A» (`A → B ≡ ¬B → ¬A`).  
   - **Поглощение**: «A или (A и B)» равно просто A.  
   - **Дистрибутивность**: «A и (B или C)» равно «(A и B) или (A и C)».  
   Эти правила — как шпаргалка для работы с логикой.  

9. **Правила вывода исчисления высказываний**  
   Это способы доказывать новые факты из старых. В документе они не описаны подробно, но обычно это:  
   - Если знаешь, что «A ведёт к B» и A правда, то B тоже правда (модус поненс).  
   - Если «A ведёт к B» и B ложно, то A тоже ложно (модус толленс).  
   Это как логические шаги, чтобы прийти к выводу.  

10. **Метод резолюций в исчислении предикатов**  
   Это способ доказать, правда ли набор логических утверждений. Работает так:  
   - Берём набор утверждений (дизъюнктов, например, «A или B»).  
   - Если есть «пустое» утверждение, набор противоречив.  
   - Ищем утверждения, которые можно соединить (унифицировать), и создаём новое утверждение (резольвенту).  
   - Повторяем, пока не докажем или не застрянем.  
   Пример: доказываем, что `R(a, z)` следует из набора утверждений, заменяя переменные и проверяя их совместимость.  

11. **Переменные, константы, утверждения, факты и правила в Прологе**  
   - **Переменные**: это как пустые коробки, куда можно положить значение. Начинаются с большой буквы (например, `X`) или с `_` (анонимная). Они временные и работают только в одном правиле.  
   - **Константы**: это конкретные имена, начинаются с маленькой буквы (например, `petya`).  
   - **Утверждения**: это либо факты, либо правила.  
     - **Факт**: что-то, что всегда правда, например, `father(petya, kolya)` (Петя — отец Коли).  
     - **Правило**: условие, например, `uncle(X, Y) :- brother(X, Z), father(Z, Y)` (X — дядя Y, если X — брат Z, а Z — отец Y).  

12. **Унификация в Prolog**  
   Унификация — это когда Пролог проверяет, можно ли «подружить» два выражения. Правила:  
   - Две константы совпадают, если они одинаковые (например, `petya = petya`).  
   - Переменная может стать константой или функцией (например, `X` может стать `petya`).  
   - Две функции совпадают, если у них одинаковое имя и аргументы.  
   Это как игра в пазлы: Пролог ищет, как сложить кусочки.  

13. **Основные правила машинного вывода Пролога**  
   Пролог решает задачи, проверяя, правда ли запрос, по базе знаний. Правила:  
   - Запрос правда, если его части совпадают с фактами или правилами.  
   - Утверждение правда, если все его условия правда.  
   - Имена и количество аргументов должны совпадать.  
   - Пролог проверяет всё слева направо и по порядку базы знаний.  
   - Если не получается, он возвращается назад и пробует другой путь (это называется backtracking).  

14. **Вычисление цели и механизм возврата**  
   - **Цель**: это запрос, который Пролог пытается доказать, например, «кто дядя Коли?». Он ищет подходящие факты или правила.  
   - **Возврат**: если путь не сработал, Пролог возвращается назад и пробует другой вариант.  
   Пример: запрос `uncle(anton, X)` находит, что Антон — дядя Коли (`X = kolya`), потом возвращается и проверяет, не дядя ли он Марка (`X = mark`).  

15. **Управление поиском решения. Пример**  
   Пролог может контролировать, как искать решения:  
   - **fail**: заставляет Пролог искать все варианты, даже если один нашёл.  
   - **! (отсечение)**: говорит «хватит искать, это всё».  
     - **Зеленое**: убирает ненужные пути.  
     - **Красное**: останавливает лишние варианты.  
   Пример:  
   - `print_all` с `fail` выводит всех матерей (Лена — мать Оли, Коли, Вики).  
   - `print_one` с `!` выводит только первую (Лена — мать Оли) и останавливается.  

16. **SWI Prolog – работа с консолью**  
   В SWI Prolog консоль — это где ты пишешь команды. Что можно делать:  
   - Перейти в папку: `chdir('путь')`.  
   - Посмотреть файлы: `ls`.  
   - Загрузить программу: `consult('file.pl')` или `['file.pl']`.  
   - Открыть файл для редактирования: `edit('file.pl')`.  
   Пример: `['1.pl', '22.pl']` загружает два файла с кодом.  

17. **SWI Prolog – основы трассировки и отладки**  
   Трассировка — это когда ты следишь, как Пролог решает задачу.  
   - Команда `trace` включает режим, где видно каждый шаг:  
     - `CALL`: начал проверять цель.  
     - `EXIT`: цель доказана.  
     - `FAIL`: цель не удалась.  
     - `REDO`: вернулся назад, ищет другой путь.  
   - `guitracer` открывает графический отладчик, где видно, какие переменные и шаги используются.  
   Пример: `trace(goal)` показывает, как Пролог ищет, кто дядя Коли.  

18. **Использование списков в Prolog**  
   Список в Прологе — это набор элементов, как вагончики поезда.  
   - Пустой список: `[]`.  
   - Непустой: `[H|T]` (H — первый элемент, T — остальные).  
   Пример: подсчёт длины списка:  
   ```prolog
   length([], 0). % Пустой список имеет длину 0
   length([_|T], L) :- length(T, R), L is R + 1. % Длина = длина хвоста + 1
   ```  
   Ещё пример: сортировка пузырьком, где элементы меняются местами, если стоят неправильно.  

19. **SWI Prolog. Юнит тестирование**  
   Юнит-тесты — это способ проверить, правильно ли работает код. В SWI Prolog используют модуль `plunit`.  
   - Пишешь тесты в блоке `begin_tests`/`end_tests`.  
   - Тесты проверяют:  
     - Работает ли код (например, находит ли элемент в списке).  
     - Ломается ли на неправильных данных (например, пустой список).  
     - Даёт ли правильные значения (например, `X = a` в списке `[a, b, c]`).  
   - Запускаешь тесты командой `run_tests`.  
   Пример: тесты для функции `find`, которая ищет элемент в списке, проверяют, что она находит элементы в начале, середине или конце списка.  

**Про `:-` (дополнительный вопрос)**  
`:-` в Прологе — это как слово «если» или команда.  
- В правилах: `uncle(X, Y) :- brother(X, Z), father(Z, Y)` значит «X — дядя Y, если X — брат Z, а Z — отец Y».  
- В командах: `:- consult('file.pl')` значит «Пролог, загрузи этот файл».  

**Про преобразование «ящерица у травы» (дополнительный вопрос)**  
Фраза «Если ящерица у травы, то ящерица зеленая» правильно записана как:  
```prolog
зеленая(ящерица) :- у(ящерица, трава).
```  
Это значит: «Ящерица зеленая, если она у травы». Всё верно, потому что `зеленая(ящерица)` — результат, а `у(ящерица, трава)` — условие.  

Если что-то ещё нужно объяснить проще или подробнее, дай знать!