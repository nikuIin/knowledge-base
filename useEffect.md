[[Frontend.canvas|Frontend canvas]]
[[Hooks хуки в frontend]]

 **`useEffect`** — это *хук* в React, который позволяет:

- **привязать события**,  
- обновлять данные,  
- или выполнять определённую логику в ответ на изменение какого-либо события.

---

### Основные возможности `useEffect`:

- Можно **привязать хук к конкретным изменениям данных**, например — к изменению определённой переменной.
- Если **передать в `useEffect` какую-то переменную** в массив зависимостей, то код внутри хука будет вызываться **каждый раз при изменении этой переменной**.
- Если **не передать никаких зависимостей**, то код в `useEffect` выполнится **только один раз при монтировании компонента**.
- Без использования `useEffect`, если вынести код внутрь компонента, он будет вызываться при каждом рендеринге. 

---

**Важно**: не важно сколько параметров было передано в массив `dependency`, хоть 0, хоть все, `useEffect` <b><u>гарантированно</u></b> сработает 1 раз при монтировании.

### Цикл жизни useEffect (важно)

`useEffect`, как и остальные хуки в `React` при обновлении должен «разрушиться» (очиститься) и обновиться, то есть принять новое значение. И самое главное, что «разрушение» идет только при **последующем вызове**. А так как `useEffect` всегда срабатывает при монтировании, то при последующем изменении сработает сначала очистка, а только потом нужный код

## Почему нужна очистка?

Пример: внутри `useEffect` мы создаём подписку на событие или запускаем таймер. Если компонент будет удалён из DOM, то подписка или таймер **будут продолжать работать**, если их не остановить/отписаться. Это может привести к:

- Утечкам памяти (ресурсы не освобождаются),
- Ошибкам при изменении состояния несуществующего компонента (вызывать setState после размонтирования),
- Нежелательному поведению (например, таймер продолжает тикать).

## Как работает очистка?

Если функция, переданная в `useEffect`, возвращает другую функцию, эта возвращаемая функция React вызовет:

- Перед повторным вызовом эффекта (при изменении зависимостей),
- Перед размонтированием компонента (когда он уходит из DOM).
## Пример с таймером и очисткой

```jsx
import React, { useState, useEffect } from "react";

function Stopwatch() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    // Очистка — остановить таймер при размонтировании
    return () => {
      clearInterval(intervalId);
      console.log("Таймер остановлен");
    };
  }, []); // Пустой массив — эффект запустится один раз при монтировании

  return <div>Прошло секунд: {seconds}</div>;
}
```
## Что будет без очистки?

Если не очистить таймер, он продолжит работать и по мере снятия компонента из DOM будет пытаться обновлять состояние компонента, что вызовет ошибки или предупреждения в консоли.
## Очистка подписок и слушателей

Точно так же при работе с подписками (например, WebSocket, событиями DOM) нужно отписываться в очистке:

```jsx
useEffect(() => {
  const handleResize = () => console.log('Resize!');
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```
### А также

1.	`useEffect` используется чтобы:
	•	Выполнять побочные эффекты после рендера.
	•	Обрабатывать подписки, таймеры, сетевые запросы, синхронизацию с внешними API и прочее.
	•	Управлять жизненным циклом эффекта с помощью очистки.
```jsx
import React, { useEffect, useState } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    // Функция очистки выполняется при размонтировании компонента
    return () => {
      clearInterval(intervalId);
      console.log('Таймер остановлен');
    };
  }, []); // запускается один раз при монтировании

  return <div>Прошло секунд: {seconds}</div>;
}
```
2.	Правильное указание зависимостей обеспечивает актуальность и предотвращает баги.
```jsx
import React, { useEffect, useState } from 'react';

function UserGreeting({ userName }) {
  useEffect(() => {
    console.log(`Привет, ${userName}!`);

    // Допустим, есть подписка, которую нужно очистить
    return () => {
      console.log(`Прощай, ${userName}...`);
    };
  }, [userName]); // Эффект запускается при изменении userName

  return <h1>Добро пожаловать, {userName}</h1>;
}
```
3.	Отличие `useEffect` от `useLayoutEffect`.`useEffect` выполняется после обновления DOM, а `useLayoutEffect` — синхронно после изменений, но перед отображением браузером.
```jsx
import React, { useEffect, useLayoutEffect, useRef } from 'react';

function Example() {
  const divRef = useRef();

  // Выполняется после рендера, после обновления DOM, асинхронно
  useEffect(() => {
    console.log('useEffect');
    // Здесь DOM уже изменён, можно делать запросы и т.п.
  });

  // Выполняется синхронно после изменений и перед отображением браузеру
  useLayoutEffect(() => {
    console.log('useLayoutEffect');
    // Можно измерить размеры элементов, внести корректировки до отображения
    const width = divRef.current.offsetWidth;
    console.log('Ширина элемента:', width);
  });

  return <div ref={divRef}>Текст</div>;
}
```

### Практическое применение:

Если нужно выполнить некоторую операцию, например, считать значение переменной из `LocalStorage` **только один раз**, лучшая практика — использовать `useEffect` с **пустым массивом зависимостей `[]`**:

```jsx
useEffect(() => {
  const value = localStorage.getItem('key');
  // обработка значения
}, []);
```

### Итоговая логика использования:

- Если вы хотите выполнить функцию **один раз при монтировании**, используйте `useEffect` с пустым массивом.  
- Если хотите, чтобы функция запускалась **при изменении определённых данных**, укажите эти переменные в массив зависимостей.  

Таким образом, `useEffect` позволяет эффективно управлять жизненным циклом компонент и обновлениями, не вызывая лишних рендеров и обеспечивая оптимальную производ.
Очистка в `useEffect` — очень важный механизм, который помогает предотвратить утечки памяти и нежелательное поведение, когда компонент размонтируется или эффект перезапускается.