[[postgreSQL]]

__Примеры тригеров__:
* Видение логирования:
```sql
create table client(
  client_id bigint generated always as identity primary key,
  first_name varchar(255) not null check(length(first_name) > 0),
  last_name varchar(255) check(length(last_name) > 0),
  middle_name varchar(255) check(length(middle_name) > 0)
);

create table client_log (
  client_log_id bigint generated always as identity primary key,
  client_id bigint not null references client(client_id),
  action varchar(255) not null,
  old_first_name varchar(255),
  old_last_name varchar(255),
  old_middle_name varchar(255),
  new_first_name varchar(255),
  new_last_name varchar(255),
  new_middle_name varchar(255),
  change_time timestamp not null default current_timestamp
);

-- создаём функцию для тригера
create or replace function log_client()
returns trigger
language plpgsql
as $$
begin
  insert into client_log(
    client_id,     action,          old_first_name,
    old_last_name, old_middle_name, new_first_name,
    new_last_name, new_middle_name, change_time
  ) values (
    new.client_id, tg_op, old.first_name,
    old.last_name, old.middle_name,
    new.first_name, new.last_name, new.middle_name,
    current_timestamp
  );
  return new;
end;
$$;

-- создаём тригер на операция вставки и обновления
create or replace trigger client_log_trigger
after insert or update
on client
for each row
execute function log_client();

-- теперь наша табличка для логов будет записывать данные
--4, 10010, 'INSERT', null, null, null, 'Ваня', null, null, '2025-04-05 10:08:09.752746'

--5, 10010, 'UPDATE', 'Ваня', null, null, 'Ваня', 'Никулин', null, '2025-04-05 10:08:43.028630'
```

* вешаем **сложную** проверку с помощью `тригера`
```sql
-- create trigger to add element to assignment
CREATE OR REPLACE FUNCTION check_assignment_element_position()
  RETURNS TRIGGER AS $$
DECLARE
  field_width SMALLINT;
  field_height SMALLINT;
  start_x SMALLINT;
  start_y SMALLINT;
  end_x SMALLINT;
  end_y SMALLINT;
  position_taken BOOLEAN;
BEGIN

  SELECT gfa.field_width, gfa.field_height, gfa.start_x, gfa.start_y, gfa.end_x, gfa.end_y
  INTO field_width, field_height, start_x, start_y, end_x, end_y
  FROM game_field_assignment gfa
  WHERE gfa.assignment_id = NEW.assignment_id;

  IF NEW.pos_x < 1 OR NEW.pos_x > field_width OR NEW.pos_y < 1 OR NEW.pos_y > field_height THEN
    RAISE EXCEPTION 'Position (X: %, Y: %) trespasses. (Width: %, Height: %)',
    NEW.pos_x, NEW.pos_y, field_width, field_height;
  END IF;

  if (NEW.pos_x = start_x and NEW.pos_y = start_y) or (NEW.pos_x = end_x and NEW.pos_y = end_y) then
    raise exception 'Position (X: %, Y: %) is start or end point. You cant put element to this kind position.',
      NEW.pos_x, NEW.pos_y;
  end if;

  -- we need to check that position doesn't taking by another element.
  SELECT EXISTS (
    SELECT 1
    FROM assignment_element
    WHERE assignment_id = NEW.assignment_id
      AND pos_x = NEW.pos_x
      AND pos_y = NEW.pos_y
      AND assignment_element.assignment_element_id != NEW.assignment_element_id -- if element already
                                                                                -- exists skip checking
  ) INTO position_taken;

  IF position_taken THEN
    RAISE EXCEPTION 'Position (X: %, Y: %) already taken by another element.', NEW.pos_x, NEW.pos_y;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER assignment_element_position_check
  BEFORE INSERT OR UPDATE ON assignment_element
  FOR EACH ROW
EXECUTE PROCEDURE check_assignment_element_position();

```
Правила
---
Пример `rule`:

* `safe delete` в `postgresql`
```sql
create table deleted_client (like client including all);

-- еще один способ создать мягкео удаление
create or replace rule safe_delete_client as
on delete to client
do instead insert into deleted_client (c1, c2, c3) values (old.c1, old.c2, old.c3);
```
* не даём обновлять данные:
```sql
-- хер кто теперь обновит
create or replace rule update_client as
on update to client
do instead nothing;
```