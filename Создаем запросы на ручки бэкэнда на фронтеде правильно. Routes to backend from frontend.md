[[Frontend]]


Для правильного обращения к ручкам бэкэнда, можно, да даже нужно использовать такой подход:

1. Определить директорию `api/`, в которой будут содержаться файлы для обращения к бэкэнду
Пример:
```bash
├── api
│   ├── apiClient.tsx
|	|-- config.tsx
│   └── auth
│       ├── errors
│       │   └── auth_errors.tsx
│       └── telegramLogin.tsx
```

2. `apiClient.tsx` — общий файл для всех ручек, работает с файлом конфигурации
```tsx
// A general api enty point to the backend application

import axios, { AxiosInstance } from 'axios';
import { API_CONFIG } from 'config';

export const apiClient: AxiosInstance = axios.create({
    baseURL: API_CONFIG.BASE_URL,
    headers: {
        'Content-Type': 'application/json' // default value, methods could override this
    },
});
```

3. Создать ручку, например `telegramLogix.tsx`
```tsx
// Login endpoint function

import { apiClient } from "../apiClient";
import { API_CONFIG } from "../config";

export const telegramLogin = async (initData: string) => {
    const response = await apiClient.post(
        API_CONFIG.ENDPOINTS.LOGIN,
        JSON.stringify(initData)
    );
    return response.data;
};
```

Файл конфигурации, который хранит сведения о ручках и о хосте бэкэнда (а лучше вынести в отдельный хук и расположить его в `hooks/`):

```tsx
// Configuration api endpoints file

export const API_CONFIG = {
    // backend url/host
    BASE_URL: import.meta.env.VITE_BASE_API_URL,
    // list of endpoints
    ENDPOINTS: {
        LOGIN: '/api/v1/login/',
        GET_USER_STATISTICS: '/api/v1/statistics'
    }
}
```


4. Создаем `хук` для работы с данными

```bash
├── hooks
│   ├── auth
│   │   └── useTelegramAuth.tsx
│   ├── user
│   │   └── getUserStatisticsHook.tsx
│   └── waitingResponse.tsx
```

```tsx
// useTelegramAuth
import { useCallback, useState } from "react";
import { telegramLogin } from "../../api/auth/telegramLogin";
import { ERROR_MESSAGES } from "../../core/constants/errorsMessages";
import { DEFAULT_TIMEOUTS } from "../../core/constants/timeout_values";
import { NotTelegramWebAppError } from "../../errors/auth_errors";
import { ServerUnvailableErorr } from "../../errors/server_errors";
import { TelegramLoginResponse } from "../../schemas/api_schemas/authShemas";
import { TelegramWebApp } from "../../schemas/telegramSchemas";
import { withTimeout } from "../waitingResponse";

// Custom hook for handling Telegram authentication
export const useTelegramAuth = () => {
    // State to track authentication status: loading, success, or error
    const [authStatus, setAuthStatus] = useState < "loading" | "success" | "error" > ("loading");
    const [error, setError] = useState < string | null > (null);

    // Memoized function to send login request to backend
    const loginWithTelegram = useCallback(async (initData: string) => {
        try {
            // Call telegramLogin with timeout to prevent hanging
            const response: TelegramLoginResponse = await withTimeout(
                telegramLogin(initData),
                DEFAULT_TIMEOUTS.API_REQUEST_TIMEOUT, // TODO: take timeouts from configuration file
                ERROR_MESSAGES.TIMEOUT_AUTH_ERROR
            );

            console.debug(response);

            // Check if login was successful
            if (response.status === "success") {
                // DO SOMETHING
            } else {
                throw new NotTelegramWebAppError(
                    response.message
                    || ERROR_MESSAGES.TELEGRAM_WEBAPP_ERROR
                );
            }
        } catch (error: any) {
            console.error(error);
            throw new ServerUnvailableErorr(
                error.response?.data?.detail
                || ERROR_MESSAGES.SERVER_ERROR
            );
        }
    }, []);

    // Memoized function to retrieve Telegram initData
    const getTelegramInitData = useCallback((telegram: TelegramWebApp | undefined) => {
        // Check if Telegram WebApp is available
        if (!telegram) {
            throw new NotTelegramWebAppError(
                ERROR_MESSAGES.TELEGRAM_WEBAPP_ERROR
            );
        }

        // Run Telegram WebApp initialization
        // TODO: replace telegram-run commands to the another module
        telegram.ready();
        telegram.expand(); // Expand WebApp to full screen

        const initData = telegram.initData || null;

        // Validate initData
        if (!initData) {
            throw new NotTelegramWebAppError(
                ERROR_MESSAGES.TELEGRAM_NO_INIT_DATA
            );
        }

        return initData;

    }, []);

    // Memoized function to perform Telegram authentication
    const telegramAuthentificate = useCallback(async () => {
        try {
            setAuthStatus("loading");
            // Clear any previous errors
            setError(null);

            // Get Telegram WebApp instance
            const telegram: TelegramWebApp | undefined = window.Telegram?.WebApp;
            // Retrieve initData from Telegram
            const initData = getTelegramInitData(telegram);

            // Send login request to backend
            await loginWithTelegram(initData);

            // Set status to success if login completes
            setAuthStatus("success");
        } catch (error: any) {
            // Set status to error if login failed
            setAuthStatus("error");
            setError(error.message);
            console.error(error.name);
            // TODO: validate errors
            // TODO: sent the exception for some journal-service
        }
    }, []);

    return { pageStatus: authStatus, error, telegramAuthentificate };
};
```