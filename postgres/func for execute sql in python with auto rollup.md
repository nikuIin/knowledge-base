```python
import psycopg2

def execute_sql(conn, sql, params=None, commit=False):
    """
    Выполняет SQL-запрос с обработкой ошибок и опциональным коммитом.

    Args:
        conn: Объект соединения psycopg2.
        sql: Текст SQL-запроса.
        params: Параметры для запроса (для защиты от SQL-инъекций).
        commit: Нужно ли коммитить транзакцию после выполнения запроса.
                Игнорируется, если conn находится в режиме автокоммита.

    Returns:
        Результат выполнения запроса (например, fetchall, fetchone, rowcount).
        Может возвращать None, если запрос не возвращает данных.

    Raises:
        psycopg2.Error: Если произошла ошибка при выполнении запроса.
    """
    try:
        with conn.cursor() as cur:
            cur.execute(sql, params)
            # Если запрос возвращает данные, получаем их
            try:
                result = cur.fetchall()
            except psycopg2.ProgrammingError: # Для запросов без возвращаемого результата
                result = cur.rowcount # Возвращаем количество измененных строк.
            if commit:
                conn.commit()
            return result
    except psycopg2.Error as e:
        conn.rollback()  # Откатываем транзакцию в случае ошибки
        print(f"Ошибка при выполнении SQL: {e}")
        raise  # Перевыбрасываем исключение для обработки на более высоком уровне

# Пример использования
def my_function(conn, value1, value2, id_value):
    """
    Пример функции, использующей execute_sql для выполнения нескольких запросов в транзакции.
    """
    try:
        # Отключаем автокоммит для управления транзакцией
        conn.autocommit = False

        # Выполняем запросы с помощью execute_sql
        execute_sql(conn, "INSERT INTO table1 (col) VALUES (%s)", (value1,))
        execute_sql(conn, "UPDATE table2 SET col = %s WHERE id = %s", (value2, id_value))

        # Если все прошло успешно, коммитим транзакцию
        conn.commit()
        conn.autocommit = True # Возвращаем автокоммит
        print("Транзакция успешно завершена")

    except psycopg2.Error as e:
        # Если произошла ошибка, откатываем транзакцию (уже сделано в execute_sql)
        print(f"Ошибка в my_function: {e}.  Откат выполнен.")
        conn.autocommit = True # Возвращаем автокоммит
        raise  # Перевыбрасываем исключение, чтобы его можно было обработать выше
```

Преимущества использования функции-обертки:

1. Централизованная обработка ошибок: Функция execute_sql инкапсулирует обработку исключений psycopg2.Error. Это означает, что вам не нужно дублировать код try...except conn.rollback() в каждом месте, где вы выполняете SQL-запрос. Это делает ваш код чище и менее подверженным ошибкам.

2. Упрощение транзакций: Функция позволяет указать, нужно ли зафиксировать (commit) изменения сразу после выполнения запроса. Это упрощает управление транзакциями, особенно если у вас есть несколько запросов, которые должны быть выполнены как единое целое. Если в режиме автокоммита - параметр commit игнорируется.
3. Безопасность (защита от SQL-инъекций): Функция execute_sql использует параметризованные запросы (params=None) для защиты от SQL-инъекций. Важно всегда использовать параметризованные запросы вместо конкатенации строк для построения SQL-запросов.
4. Повторное использование и уменьшение дублирования кода: Вместо того, чтобы каждый раз писать код для выполнения запроса, обработки ошибок и (возможно) коммита, вы просто вызываете execute_sql. Это значительно упрощает код и делает его более читаемым.
5. Легкость изменения логики: Если вам когда-нибудь понадобится изменить способ обработки ошибок, логирование запросов, или добавить какие-то дополнительные функции (например, повторные попытки при временных ошибках подключения), вы можете сделать это в одном месте – в функции execute_sql. Вам не придется менять код во всем приложении.
6. Улучшенная читаемость кода: Вместо того чтобы видеть низкоуровневый код cur.execute, conn.commit, conn.rollback, вы видите вызов execute_sql, который более явно выражает намерение.

Как использовать эту функцию:

1. Создайте соединение: Используйте psycopg2.connect() для установки соединения с вашей базой данных.
2. Вызывайте execute_sql: Вызывайте execute_sql для каждого SQL-запроса, который вам нужно выполнить, передавая соединение, SQL-запрос и параметры (если есть).
3. Управляйте транзакциями: Для транзакций, отключайте autocommit, и потом вызывайте conn.commit() или полагайтесь на conn.rollback() в случае ошибки. Для простых запросов, где не нужна транзакция, можно использовать conn.commit() (если вы не находитесь в режиме автоматического коммита, который включен по умолчанию).

Важные замечания:

•  Всегда закрывайте соединение: Хотя функция execute_sql закрывает курсор, вы по-прежнему должны закрывать соединение с базой данных, когда закончите с ним работать. Лучше всего использовать with psycopg2.connect(...) as conn: для автоматического закрытия соединения.
•  Обработка исключений на верхнем уровне: Хотя execute_sql обрабатывает исключения psycopg2.Error и откатывает транзакцию, вам, вероятно, все равно захочется обрабатывать исключения на более высоком уровне в вашем приложении, чтобы можно было предпринять какие-то действия (например, отобразить сообщение об ошибке пользователю, записать ошибку в лог-файл, или повторить попытку операции). Именно поэтому execute_sql перевыбрасывает исключение после его обработки.
• Возвращаемые значения: Обратите внимание, что функция execute_sql возвращает результат запроса, если он есть. Это может быть fetchall(), fetchone(), rowcount (количество строк, затронутых запросом) или None, если запрос не возвращает данных.

Создание такой функции-обертки – это отличный способ сделать ваш код psycopg2 более чистым, безопасным, надежным и простым в обслуживании.