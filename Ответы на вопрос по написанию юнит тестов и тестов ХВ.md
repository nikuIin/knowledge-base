[[Pytest Тестирование.canvas|Pytest Тестирование]]
[[Тон хорошего тестирования. Хорошее unit тестирование.]]
[[ХВ]]
[[Ответы на вопросы]]

> [!Вопрос: что тестировать?] 
> Всем привет, читаю «Принципы юнит-тестирования» Хорикова. Автор говорит, что юнит-тесты должны проверять 1 единицу поведения программы и должны быть написаны на основную бизнес логику. Для вопроса приведу пример:
 >- есть сервис, отвечающий за работу со статьями, у него есть методы:
>- полнотекстовый поиск
>	  - приватный метод по переводу строки текста -> множество слов 
>	  - для поиска (вызывается в методе полнотекстового поиска)
> 
Если опираться на то, что юнит тест должен проверять именно 1 единицу поведения, то мне стоит писать только тест на метод полнотекстового поиска, где просто будет вызываться метод конвертации строки? Или же сам метод конвертации можно считать за единицу поведение программы, хоть сам он не являются частью бизнес логики?  
Если что, интересует именно правильное понимание определения «юнит-теста» с точки зрения Хорикова. В проекте я написал и буду использовать тест на приватный метод, мне само написание теста помогло его улучшить:)


### Ответ 1 (Egor Vavilov (@Shecspi)):

Для меня unit - минимально возможная часть кода. Функция, которая зависит только от своих параметров и ни от чего больше. И таким образом, всегда гарантирует одинаковые выходные данные при одинаковоых входных данных. Чистая функция одним словом.
Если, например, у тебя функция полнотекстового поиска выглядит так:

```python
def search(text, query):
    return query.lover() in text.lover()
```

То в таком случае это полноценный юнит и его можно тестировать юниттестом. А если, например, эта функция читала бы text из файла, а не брала бы из параметра, то это уже был бы не юнит. И тестировать сложнее было бы, нужно мокать файл.

### Ответ 2 (Anton Artikov (@mistandok))

![[audio_2025-07-25_12-51-52.ogg]]


### Резюме

Из ответов понял, что тесты можно писать на то, на что ты хочешь. Но привязывать, например к `CI/CD` нужно только тесты, проверяющие бизнес логику (открытые метода классов). Потому что реализация приватных методов часто меняется и тогда тесты привязываются к реализации программы, что плохо. Тесты должны проверять ее поведение, то есть ответы публичных методов. Поддерживать тесты на приватные методы дорого и нецелесобразно. Также они никак не гарантируют правильную работы твоей программы (так это лишь ее реализация, а не сама суть).

Пиши тесты лучше на сам метод, который эту приватную фукнцию вызывает. Так ты проверишь поведение программы при специфичных кейсах, это намного лучше. 