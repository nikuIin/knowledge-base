[[postgreSQL]]
[[Добавляем возможность подключения по SSH домену и пользователям к postgreSQL]]

1. Включайте **checksums**

Включить контрольные суммы можно при создании кластера командой `initdb`:

```
initdb --data-checksums -D /var/lib/postgresql/data
```

Если база данных уже создана и работает, то можно тоже включить checksums с помощью встроенной утилиты `pg_checksums`, но это потребует даунтайма.


```
pg_checksums --enable -D /var/lib/postgresql/data
```

2. Настройте **autovacuum**

Вакуум это важный процесс, который удаляет мертвые строки и предотвращает раздувание таблиц, когда они начинают неоправданно занимать слишком много места. Помните, мы говорили про MVCC и про то, что одновременно может храниться несколько версий строки? Вот. В постгресе есть параметр `autovacuum_vacuum_scale_factor`, по умолчанию его значение 0.2, что означает, что автовакуум будет запускаться только при изменении 20% таблицы, что довольно много для больших таблиц. Лучше уменьшить это число, пусть запускается по чуть-чуть и почаще. Конкретные цифры тут рекомендовать сложно, надо тестировать в каждом конкретном случае, но 10 или 5% выглядят более правильным значением этого параметра.

Аналогично есть параметр `autovacuum_analyze_scale_factor` — это как часто будет запускаться анализ таблиц, который собирает статистику по данным. Это тоже очень важный процесс, потому что исходя из собранной статистики планировщик запросов будет строить план этого запроса. Дефолтное значение 10%, тоже можно попробовать уменьшить, чтобы статистика запускалась почаще. Например, до 5% или даже до 3%.

Также можно увеличить `vacuum_cost_limit` с 200 до 2000 на мощных серверах. Надо тестить.

3. Время от времени выполняйте **VACUUM FULL** или запускайте **pg_repack**

Мы уже говорили о `VACUUM FULL`. Эта команда в отличие то просто `VACUUM` пересобирает таблицы таким образом, чтобы место, занятое мертвыми строками, действительно освободилось. Обычный `VACUUM` просто помечает это место как свободное, чтобы туда могли записаться новые строки таблицы, но пока они туда не записались, это место просто пустует.

`VACUUM FULL` автоматически не запускается, так как это блокирующая операция, чтобы не было даунтайма у сервиса. Мы можем ночью когда-то в минимальную нагрузку запускать это или настроить запуск периодический неблокирующего `pg_repack` по крону, например. Это стандартный планировщик задач в Linux. Дальше посмотрим в курсе на него, когда будем настраивать сервера.

4. Включить **логирование** медленных запросов

За это отвечает `log_min_duration_statement`. Если его установить в 500, то всё, что дольше 500мс будет логироваться.

5. Настроить **work_mem** и **hash_mem_multiplier**

По умолчанию PostgreSQL выделяет очень мало памяти на сортировки и хеш-джойны, `work_mem = 4MB`. Можно поднять его до, например, 64 мегабайт. Опять же надо тестировать. Этот параметр можно менять в конкретной сессии, где крутится какой-то сложный запрос, для них можно поднимать этот параметр и до 256 мегабайт при необходимости.

Вообще ограничение памяти для хэш-таблицы вычисляется путем умножения `work_mem` на `hash_mem_multiplier`. Это позволяет операциям, основанным на хешировании, использовать объем памяти, превышающий обычный базовый объем `work_mem`. Поэтому этот параметр тоже можно регулировать.

6. Используйте **pg_stat_statements** для анализа нагрузки

Добавляем в `postgresql.conf`:

```sql
shared_preload_libraries = 'pg_stat_statements'
```

Перезапускаем PostgreSQL, подключаем расширение:

```sql
create extension pg_stat_statements;
```

И можно смотреть на самые тяжелые запросы:

```sql
select query, calls, total_time, mean_time
from pg_stat_statements
order by total_time desc
limit 10;
```

7. Увеличьте **random_page_cost**

Для быстрых SSD-дисков стоит уменьшить этот параметр до 1.1-1.5. По умолчанию он 4 и это слишком много.

8. Настройте **shared_buffers**

Это количество оперативной памяти, которую PostgreSQL использует для буферного кеша. Поставьте 25-40% от объёма оперативной памяти на сервере. Буферный кеш снижает количество обращений к диску и тем самым ускоряет выборки данных, в нём кешируются страницы как таблиц, так и индексов.

9. Настройте **effective_cache_size**

Это оценка для оптимизатора запросов. Поставьте её в размере 50-75% от объёма оперативной памяти на сервере.

10. Настройте **maintenance_work_mem**

Это количество памяти, доступное для процессов обслуживания БД. Поставьте 1-2 гигабайта.