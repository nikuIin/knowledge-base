[[FSD Entity]]
[[Frontend.canvas|Frontend canvas]]

Компоненты в React должны динамически обновляться, и *полностью* обновлять страницу не всегда уместно. Поэтому мы можем подвязать какой-то компонент к ивенту обновления. И для этого нам нужно как раз создать место, где состояние `entity`, то есть состояние какой-то доменной сущности, будет сохраняться, и меняться, и выдаваться по определенному ивенту.

И это как раз и является целью файла `Store`. Еще раз, цель `Store` — создать реактивное хранилище состояния объекта и привязать его к событиям, чтобы потом можно было разделить состояние между UI-компонентами и гибко управлять его изменением с помощью этих событий. 

```ts
import { createStore, createEvent } from "effector";
import type { User } from "./types";

export const setUser = createEvent<User>();
export const clearUser = createEvent();

export const $currentUser = createStore<User | null>(null)
  .on(setUser, (_, user) => user)
  .on(clearUser, () => null);

export const $isAuth = $currentUser.map(Boolean);
```

Как мы видим из примера, мы создаем два события: `CreateEvent`, который принимает `юзера`, и `ClearUser`, который очищает `юзера`. Затем мы создаем объект `Store` под названием `$currentUser`.  Так (начиная с $) принято называть `Store` объекты, чтобы было сразу понятно, за что отвечает эта переменная.  

Мы привязываем этот `Store` к двум событиям: `SetUser` и `ClearUser`.  

Потом мы привяжем UI-компоненты к `CreateStore`, который принимает либо `юзера`, либо `null` (по умолчанию `null`).
И тем самым мы сможем динамично управлять всеми UI-компонентами. Например шапкой сайта (отображать аватарку пользователя или нет).
Потом мы создаем дочерний `Store`-компонент `$isAuth`, который как раз проверяет, пустой ли `store`-`$currentUser`.  Если он не пустой, то возвращает `true`, если пустой, то `false`. 