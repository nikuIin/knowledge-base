[[Ищем «плохой» коммит. Бинарный поиск. git bisect]]

Команда `git bisect` — это мощный инструмент для бинарного поиска в истории коммитов Git, который помогает найти коммит, вызвавший ошибку или проблему в коде. Она особенно полезна, когда вы хотите определить, в каком коммите появилась ошибка (например, баг), если вы знаете, что раньше код работал корректно. Я объясню, как работает `git bisect`, и покажу это на конкретном примере.

---

### Как работает `git bisect`?
`git bisect` использует бинарный поиск для эффективного сужения диапазона коммитов, в котором появилась проблема. Вы указываете:
- **Хороший (good)** коммит, где код работал корректно.
- **Плохой (bad)** коммит, где проблема уже присутствует (обычно это текущий HEAD).
Git автоматически переключается между коммитами в истории, деля диапазон пополам, чтобы вы могли проверить, есть ли баг в каждом из промежуточных коммитов. После каждого теста вы отмечаете коммит как `good` или `bad`, пока Git не найдет точный коммит, вызвавший проблему.

---

### Основные команды
1. **Начать бинарный поиск**:
   ```bash
   git bisect start
   ```
2. **Указать плохой коммит** (где баг есть):
   ```bash
   git bisect bad <commit-hash>
   ```
   Если вы не указываете хэш, Git считает текущий HEAD плохим:
   ```bash
   git bisect bad
   ```
3. **Указать хороший коммит** (где бага не было):
   ```bash
   git bisect good <commit-hash>
   ```
4. **Проверять коммиты**:
   Git будет переключаться на промежуточные коммиты. Вы тестируете код (например, запускаете тесты или проверяете баг вручную) и отмечаете каждый коммит:
   - Если баг есть:
     ```bash
     git bisect bad
     ```
   - Если бага нет:
     ```bash
     git bisect good
     ```
5. **Завершить бинарный поиск**:
   Когда Git находит проблемный коммит, завершаете процесс:
   ```bash
   git bisect reset
   ```
   Это возвращает вас к исходной ветке или коммиту, с которого вы начали.

---

### Пример: Поиск бага с помощью `git bisect`

#### Сценарий
Предположим, у вас есть репозиторий с проектом на Python, где в какой-то момент в функции `calculate_sum` появился баг: она начала возвращать неправильные результаты. Вы знаете, что баг есть в текущем состоянии ветки `main` (HEAD), но раньше (например, в коммите с хэшем `abc123`) код работал корректно. Вы хотите найти коммит, который сломал функцию.

#### Исходный код (для контекста)
Файл `math_ops.py`:
```python
def calculate_sum(a, b):
    return a + b
```

#### Шаг 1: Подготовка
1. Убедитесь, что вы находитесь в нужной ветке (например, `main`):
   ```bash
   git checkout main
   ```
2. Проверьте, что баг действительно есть. Запустите, например:
   ```bash
   python -c "from math_ops import calculate_sum; print(calculate_sum(2, 3))"
   ```
   Предположим, выводится `23` вместо ожидаемого `5` — баг подтверждён.

#### Шаг 2: Начать бинарный поиск
Запустите `git bisect`:
```bash
git bisect start
```

Укажите текущий HEAD как плохой (баг есть):
```bash
git bisect bad
```

Укажите старый коммит, где код работал (например, `abc123`):
```bash
git bisect good abc123
```

Git выведет что-то вроде:
```
Bisecting: 6 revisions left to test after this (roughly 3 steps)
[<commit-hash>] Some commit message
```
Git переключится на промежуточный коммит (где-то посередине между `bad` и `good`).

#### Шаг 3: Тестирование промежуточных коммитов
Проверьте код на текущем коммите:
```bash
python -c "from math_ops import calculate_sum; print(calculate_sum(2, 3))"
```

- Если результат неправильный (например, `23`), отметьте коммит как плохой:
  ```bash
  git bisect bad
  ```
- Если результат правильный (например, `5`), отметьте коммит как хороший:
  ```bash
  git bisect good
  ```

Git снова переключится на новый промежуточный коммит, сокращая диапазон. Например:
```
Bisecting: 3 revisions left to test after this (roughly 2 steps)
[<new-commit-hash>] Another commit message
```

Повторяйте тестирование и маркировку (`git bisect good` или `git bisect bad`), пока Git не найдёт проблемный коммит.

#### Шаг 4: Найден проблемный коммит
Когда диапазон сузится до одного коммита, Git выведет:
```
<problem-commit-hash> is the first bad commit
commit <problem-commit-hash>
Author: Some Developer <email@example.com>
Date:   Wed Jun 4 12:00:00 2025 +0000

    Introduced a bug in calculate_sum

diff --git a/math_ops.py b/math_ops.py
index 1234567..89abcde 100644
--- a/math_ops.py
+++ b/math_ops.py
@@ -1,3 +1,3 @@
 def calculate_sum(a, b):
-    return a + b
+    return str(a) + str(b)  # Ошибка: конкатенация строк вместо сложения
```

Теперь вы знаете, что баг появился в этом коммите, где вместо числового сложения (`a + b`) была введена конкатенация строк (`str(a) + str(b)`).

#### Шаг 5: Завершение
Завершите бинарный поиск, чтобы вернуться к исходному состоянию (например, HEAD ветки `main`):
```bash
git bisect reset
```

---

### Автоматизация с `git bisect run`

Если у вас есть автоматический тест для проверки бага, вы можете использовать `git bisect run` для автоматизации процесса. Например, создайте скрипт `test.sh`:
```bash
#!/bin/bash
python -c "from math_ops import calculate_sum; result = calculate_sum(2, 3); exit(0 if result == 5 else 1)"
```

Сделайте скрипт исполняемым:
```bash
chmod +x test.sh
```

Запустите `git bisect` с автоматическим тестом:
```bash
git bisect start
git bisect bad
git bisect good abc123
git bisect run ./test.sh
```

- Скрипт должен возвращать:
  - `0` для хороших коммитов (тест пройден).
  - Ненулевой код (например, `1`) для плохих коммитов (тест не пройден).
- Git автоматически перебирает коммиты, пока не найдёт проблемный, и выводит его.

После нахождения коммита завершите процесс:
```bash
git bisect reset
```

---

### Полезные советы
1. **Просмотр лога бисекта**:
   Если вы хотите увидеть, какие коммиты тестировались, используйте:
   ```bash
   git bisect log > bisect_log.txt
   ```
   Это сохранит лог всех шагов бисекта. Вы можете воспроизвести его позже с помощью:
   ```bash
   git bisect replay bisect_log.txt
   ```

2. **Пропуск коммитов**:
   Если коммит не компилируется или не может быть протестирован, отметьте его как пропущенный:
   ```bash
   git bisect skip
   ```
   Git выберет другой коммит для тестирования.

3. **Ограничение диапазона**:
   Если вы хотите искать только в определённой ветке или диапазоне коммитов, укажите путь:
   ```bash
   git bisect start HEAD abc123 -- path/to/file
   ```
   Это ограничит поиск изменениями в указанном файле или директории.

4. **Визуализация**:
   Для просмотра истории коммитов в диапазоне бисекта используйте:
   ```bash
   git bisect visualize
   ```
   Это откроет графический интерфейс (если настроен, например, `gitk`) или покажет лог коммитов.

5. **Предупреждения и осторожность**:
   - Убедитесь, что у вас чистая рабочая директория перед началом (`git stash` или закоммитьте изменения).
   - Если вы случайно отметили коммит неправильно (`good` вместо `bad`), можно перезапустить процесс или использовать `git bisect replay` с логом.

---

### Пример вывода проблемного коммита
После завершения бисекта вы получите что-то вроде:
```
<problem-commit-hash> is the first bad commit
commit <problem-commit-hash>
Author: Some Developer <email@example.com>
Date:   Wed Jun 4 12:00:00 2025 +0000

    Changed calculate_sum implementation

diff --git a/math_ops.py b/math_ops.py
index 1234567..89abcde 100644
--- a/math_ops.py
+++ b/math_ops.py
@@ -1,3 +1,3 @@
 def calculate_sum(a, b):
-    return a + b
+    return str(a) + str(b)
```

Теперь вы можете:
- Исправить баг, создав новый коммит.
- Вернуться к старому коммиту (`git checkout abc123`) и создать ветку для работы:
  ```bash
  git checkout -b fix-bug abc123
  ```

---

### Итог
`git bisect` — это эффективный способ найти проблемный коммит с минимальными усилиями благодаря бинарному поиску. В примере выше мы нашли коммит, который сломал функцию `calculate_sum`, протестировав промежуточные коммиты вручную или с помощью скрипта. Если у вас есть реальный репозиторий и баг, который нужно отследить, напишите, и я помогу адаптировать процесс под ваш случай!